<div>
  <p><b>Then() method:</b> asynchronous promise always have an initial state of pending and then will settle. We use the <samp>then()</samp> method to say to the program what to do after that : "I have a promise, here's what I want to happen when it settle". So <samp>then()</samp> will be fired only after the status of the promise has been settled (fulfilled or rejected).</p>
  <p><samp>then()</samp> is a higher-order function, it takes two callback functions as arguments. We refer to these callbacks as handlers:</p>
  <ul>
    <li>The first argument (the first handler) is called <b>onFulfilled</b> it is a success handler. It contains what to do when the promise fulfills</li>
    <li>The second argument (the second handler) is called <b>onReject</b>, it is a failure handler. It contains what to do when the promse rejects</li>
  </ul>
  <p>We can invoke <samp>then()</samp> with one, both or zero handlers</p>
  <u>Ex:</u>
  <PrismCode code={code.then} language={language} />
  <p>>>> Since <samp>prom</samp> resolves, <samp>handleSuccess()</samp> is invoked with promâ€˜s resolved value, 'Yay', so 'Yay' is logged to the console.</p>
  <p>But with typical promise, we won't know whether a promise will resolve or reject, so we need to provide the logic for either case (the success handler and the failure handler):</p>
  <PrismCode code={code.then2} language={language} />
  <p><b>catch() method:</b> to write cleaner code we use the separation of concerns principle. So we separate our resolved logic from our rejected logic:</p>
  <PrismCode code={code.catch} language={language} />
  <p>And to be even cleaner we use the <samp>catch()</samp> function. It takes only one argument: the failure handler. It is like using a <samp>then()</samp> with only the failure handler:</p>
  <PrismCode code={code.catch2} language={language} />
  <p><b>Chaining multiple promises:</b> Chaining multiple promises is called composition:</p>
  <PrismCode code={code.chainingPromises} language={language} />
  <ul>
    <li>We invoke <samp>firstPromiseFunction()</samp> witch returns a promise</li>
    <li>We invoke <samp>then()</samp> with an anonymous function as the success handler</li>
    <li>Inside the success handler we return a new promise: <samp>secondPromiseFunction()</samp> with the first promise's resolved value as a parameter. (Probably that this second promise needed the result of the first promise to run. That is why we needed to wait for the first promise to settle before runing it)</li>
    <li>We invoke a second <samp>then()</samp> to handle the logic of the second promise</li>
    <li>Inside that second <samp>then()</samp> we have a success handler which will log the second promise's resolved value to the console.</li>
  </ul>
  <p><b>2 common mistakes:</b></p>
  <ul>
    <li>Nesting promises instead of chaining them: puting the 2nd <samp>then()</samp> inside the success handler of the first promise</li>
    <li>Forgetting to return a promise. If we don't <samp>return</samp> anything inside the first <samp>then</samp>, the second <samp>then()</samp> will just handle the logic of the first promise. (It is like if we didn't have the first <samp>then()</samp>)</li>
  </ul>
</div>
