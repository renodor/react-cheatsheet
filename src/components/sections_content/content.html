<div>
  <p>Since ES8, <samp>async…await</samp> was introduced and allows a better readability and scalability of promises. Async kw is used to write function that handle asynchronous actions. Async kw allows to creates functions that return a Promise:</p>
  <PrismCode code={code.async} language={language} />
  <p>Async functions always return a promise. It will return in 3 possible ways:</p>
  <ul>
    <li>If there is nothing returned, it will return a promise with a fulfilled value of undefined</li>
    <li>If there is a non-promise value returned, it will return a promise fulfilled to that value</li>
    <li>If a promise is returned it will simply return that promise</li>
  </ul>
  <p>So, a normal promise written like that:</p>
  <PrismCode code={code.asyncVsPromise} language={language} />
  Can be written with the <samp>async</samp> kw like that:
  <PrismCode code={code.asyncVsPromise2} language={language} />
  <p><b>Await:</b> Without the <samp>await</samp> kw, an async function don't do much. The <samp>await</samp> kw can only be used inside an async function. It returns the resolved value of a promise. <samp>await</samp> will pauses the execution of the async function until the desired promise is fulfilled.
  <u>Ex:</u>
  <PrismCode code={code.await} language={language} />
  <ul>
    <li>Inside <samp>asyncFuncExample()</samp> we use <samp>await</samp> to pause our execution until <samp>myPromise()</samp> is resolved</li>
    <li>We moreover assign <samp>myPromise()</samp> resolved value to the variable <samp>resolvedValue</samp></li>
    <li>Then we log resolvedValue to the console</li>
    <li>(The <samp>resolvedValue</samp> of <samp>myPromise</samp> is "I am resolved now!")</li>
  </ul>
  <p>It is particulary usefull when you do dependent promises (a serie of asynchronous action).</p>
  <p>Indeed, with native promises you will do a chain of <samp>then()</samp> functions. Like that:</p>
  <PrismCode code={code.awaitChain} language={language} />
  <p>Whereas with <samp>async…wait</samp>:</p>
  <PrismCode code={code.awaitChain2} language={language} />
  <p><b>Try...Catch:</b> When <samp>catch()</samp> is used with a long promise chain, there is no indication of where in the chain the error was thrown. This make debugging challenging.</p>
  <p>With <samp>async…await</samp>, we use the <samp>try…catch</samp> statements for error handling:</p>
  <PrismCode code={code.tryCatch} language={language} />
  <p>Here we will "try" what is in the body of the <samp>try</samp> kw. If any of the promised will reject, the catch <samp>body</samp> will be executed, with the <samp>err</samp> argument being the reject value of the promise that was rejected.</p>
  <p><b>Handling Independent Promises:</b> If we have several independent promises that we need to await there is a trick. Indeed, we don't want to wait promise1 to be solved, then promise2 to be solved, and then do our resolution…</p>
  <p>We want both promise to run (at the same time) and then, when both are solved, we want our resolution. We can do it like that:</p>
  <PrismCode code={code.independentPromises} language={language} />
  <p><b>Await Promise.all()</b> : We can also use the <samp>await Promise.all()</samp> to wait for multiple promises. Indeed <samp>Promise.all()</samp> takes an array of promiseq as argument and will resolve when all of these promise are fulfilled. So if we put await before it, it will await all those promises to be settled before going further.</p>
  <PrismeCode code={code.awaitPromiseAll} language={language} />
</div>
